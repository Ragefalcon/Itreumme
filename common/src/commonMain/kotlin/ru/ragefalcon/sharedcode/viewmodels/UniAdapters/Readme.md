# Наблюдение данных из базы данных

SQLDelight генерит интерфейсы из файлов `*.sq` в которых в SQL формате прописаны запросы к 
базе данных. Из этих интерфейсов можно получить объекты `Query`
(<i>A listenable, typed query generated by SQLDelight.</i>),а из них можно подписаться
на обновления содержимого в формате `Flow` используя extension `.asFlow()`.

В текущей папке репозитория находятся несколько адаптеров, которые позволяют упростить
получение наблюдаемого объекта. Ниже приведен пример создания объекта такого адаптера.

```Kotlin
    val spisIdeaStap = UniConvertQueryAdapter<Spis_stap_idea, ItemIdeaStap>() {
        ItemIdeaStap(
            id = it._id,
            name = it.name,
            data = it.data_,
            opis = it.opis,
            stat = it.stat,
            idea_id = it.idea_id
        )
    }.apply {
        this.updateQuery(mDB.spisStapIdeaQueries.selectIdeaStapInIdea(idIdea = -1, sortField = "name")) 
    }
```

Первый тип в адаптере соответствует типу данных получаемых в запросе, а второй тип,
тот который будет использоваться в программе. На вход соответственно
подается конвертор из первого типа во второй. После этого указывается объект `Query` из
которого будут поступать данные (первого типа). Этот объект можно обновлять в процессе работы с помощью
той же функции `.updateQuery(query: Query<T>)`. Таким образом через данный адаптер
можно изменять параметры запроса из базы данных, например если мы хотим выборку по другим
датам или по другому связанному объекту. Из этого же адаптера можно получить объект
типа `MyObserveObj<T>`, который привязан только к конечному типу данных, а его в свою
очередь можно конвертировать в объект `ItrCommObserveObj<T>`. Класс `ItrCommObserveObj`
имеет мультиплатформенную реализацию и из него можно уже напрямую получать данные.
В целях упрощения можно было бы доработать классы адаптеров и получать объекты
`ItrCommObserveObj` напрямую из них.

Класс ItrCommObserveObj объявлен следующим образом:
```Kotlin
expect open class ItrCommObserveObj<T>(observeObj: MyObserveObj<T>) : ItrCommObserveInt
```
А вот его реализация для Android:
```Kotlin
actual open class ItrCommObserveObj<T> actual constructor(observeObj: MyObserveObj<T>): ItrCommObserveInt {
    private val ldObjValue = MutableLiveData<T>()
    private val firstSpisSchet by lazy {
        observeObj.getObserve {
            if (it!=null) {
                ldObjValue.value = it
            }
        }
    }

    fun getLiveData(): LiveData<T> {
        firstSpisSchet
        return ldObjValue
    }

    fun observe(owner: LifecycleOwner, observer: (T) -> Unit) {
        firstSpisSchet
        ldObjValue.observe(owner, observer)
    }
}
```

Все еще внутри общего модуля создается класс с наборами таких объектов:
```Kotlin
    ...
     val spisIdea = ItrCommObserveObj(objForSpis.spisIdea.getMyObserveObj())
     val spisStapIdea = ItrCommObserveObj(objForSpis.spisIdeaStap.getMyObserveObj())
    /** objForSpis.spisIdeaStap это адаптер созданный выше. */
    ...
```

Экземпляр такого класса создается уже в платформенном модуле, где его можно использовать 
следующим образом:
```Kotlin
    /** Android */
    journalSpis.spisStapIdea.observe(viewLifecycleOwner) { listStapIdea ->
     ...
    }

    /** Desktop */
    journalSpis.spisStapIdea.getState().value.let { listStapIdea ->
     ...
    }
```
Где `journalSpis.spisStapIdea` это `ItrCommObserveObj<ItemIdeaStap>`, а `listStapIdea` является `List<ItemIdeaStap>`.



---
[На главную](/)
